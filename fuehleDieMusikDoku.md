# üéµ ‚ÄûF√ºhle die Musik‚Äú ‚Äì Projektdokumentation

> **Kurs / Semester:** Prototyping Interactive Objects ‚Äì SoSe 2025  
> **Projektname:** F√ºhle die Musik  
> **Team:** Omar Assad Salem und Tarek Wais   
> **Version:** 1.0  
> **Hinweis:** Diese Dokumentation ist nach den Rubriken ‚ÄûProjekt-Doku / Demo-Pr√§sentation / Technische Tiefe‚Äú strukturiert.

---

## 1.0 Executive Summary (Kurz√ºberblick)
- Ziel: Musik **h√∂rbar**, **sichtbar** (NeoPixel) und **sp√ºrbar** (Vibration) machen.
- Kern: Arduino UNO R4 WiFi + DFPlayer Mini (MP3), DRV2605L (Haptik), LCD-Display (I¬≤C), LDR/Taster als Trigger.
- Stand: Hardware aufgebaut auf Breadboards, Basis-Software modular lauff√§hig.


### 1.1 Funktionsumfang
- **Zwei Startarten (Modi):**
  - **LDR‚ÄëTrigger:** Hand √ºber LDR ‚áí System startet eine vordefinierte Sequenz.
  - **Men√º‚ÄëModus (optional):** LCD 16√ó2 zeigt Titel aus `songs.txt`; Tasten **hoch/runter** wechseln den Song; Start erfolgt sofort (OK optional).
- **Audio (optional):** DFPlayer Mini spielt **`NNN.mp3`** (z.‚ÄØB. `001.mp3`) von microSD; **`songs.txt`** liefert **ID,Titel** f√ºr die Anzeige.
- **Licht‚ÄëMapping:** NeoPixel‚ÄëLEDs folgen CSV‚ÄëDateien **`NNN_light.csv`** mit Zeitstempeln und RGB‚ÄëWerten (*`time_ms,r,g,b`*).
- **Vibrations‚ÄëMapping:** DRV2605L spielt CSV‚Äëbasierte Haptikmuster **`NNN_vibe.csv`** (*`time_ms,pattern`*).
- **Synchronisation:** `resetAllEffects()` setzt die Zeitbasis zur√ºck, damit Licht & Vibration **gleichzeitig** starten.
- **Status/Bedienung (optional):** LCD zeigt ‚ÄûNow playing ‚Ä¶‚Äú + Songtitel; Taster **D8/D5** (hoch/runter), **D7** (OK, optional).
- **Debug & Robustheit:** Serielle Logausgabe (115200) f√ºr Fehlersuche; I¬≤C‚ÄëAdresse des LCDs per Scanner ermittelbar; Hinweise zu 5‚ÄØV‚ÄëVersorgung & gemeinsamem GND.

### 1.2 Funktionsumfang

Das Projekt wurde schrittweise entwickelt. Am Ende entstand ein System, das Musik h√∂rbar, sichtbar und f√ºhlbar macht.  
Um den Weg dorthin nachzuvollziehen, dokumentieren wir hier die wichtigsten Entwicklungsstufen.

#### Entwicklungsstufe 1: Erster Testaufbau

![Erster Testaufbau mit Arduino, Breadboard und Buzzer](./buzzer_Einsatz.jpeg)

Auf diesem Foto ist der **erste Versuchsaufbau** zu sehen:
- Ein **Arduino UNO** ist √ºber USB mit dem Laptop verbunden.
- Auf dem **Breadboard** sind ein kleiner **Buzzer** und ein **Steuerelement** angeschlossen.
- √úber einfache Kabelverbindungen wurden die Komponenten mit **5 V, GND und einem digitalen Pin** des Arduino verbunden.

üëâ Ziel dieses Schritts war es:
- Einen **einfachen Testcode** zu schreiben, der den Buzzer ansteuert.  
- Zu pr√ºfen, ob die Kommunikation zwischen Arduino und Breadboard-Schaltung funktioniert.  
- Die Grundlage f√ºr sp√§tere Erweiterungen (z. B. NeoPixel, Vibration, SD-Karte) zu schaffen.

Mit diesem Test war sichergestellt: **Das Grundsystem funktioniert.**  
Im n√§chsten Schritt wurde es um weitere Module (LDR, DRV2605L, NeoPixel) erweitert, um das Endprodukt ‚ÄûF√ºhle die Musik‚Äú zu realisieren.


#### Entwicklungsstufe 2: DFPlayer Mini mit Lautsprecher





In der zweiten Stufe wurde der **DFPlayer Mini** in das Projekt integriert.  
Dadurch konnten nun echte **MP3-Dateien** von einer microSD-Karte abgespielt werden.  

- Der **DFPlayer Mini** ist √ºber **Serial1 (Pins D0/D1)** mit dem Arduino verbunden.  
- Ein kleiner **Lautsprecher** ist direkt am DFPlayer angeschlossen (Pins SPK_1 / SPK_2).  
- Die **microSD-Karte** enth√§lt die MP3-Dateien (z. B. `001.mp3`, `002.mp3`), die automatisch erkannt werden.  

üëâ Ziel dieses Schritts war es:
- Den **Buzzer durch echte Musik** zu ersetzen.  
- Den **Audio-Teil des Endprodukts** zuverl√§ssig zum Laufen zu bringen.  
- Erste Erfahrungen mit der **Dateiverwaltung auf der SD-Karte** zu sammeln.  

üé• **Demo-Video:**  
üìπ [DFPlayer Mini ‚Äì kurzes Demo-Video](./dfPlayerEinsatz.mp4)

> Mit diesem Schritt war der Grundstein f√ºr die **Musik-Komponente** gelegt.  


#### Entwicklungsstufe 3: Erstes Geh√§use aus Pappe

![Erstes Geh√§use mit LCD und Lautsprecher√∂ffnung (Au√üenansicht)](./PappengehaeuseVonAu√üen.jpeg)
![Innenaufbau mit Arduino, Breadboard und Lautsprecher (Innenansicht)](./PappengehaeuseVonInnen.jpeg)

In dieser Stufe haben wir begonnen, die Elektronik in ein **provisorisches Geh√§use aus Pappe** einzubauen.  
Das Ziel war, ein erstes Gef√ºhl f√ºr die **Gr√∂√üe, Platzierung und Bedienbarkeit** des sp√§teren Endprodukts zu bekommen.

- Au√üen wurde eine **Aussparung f√ºr das LCD-Display** geschnitten, damit die Anzeige von au√üen sichtbar ist.  
- F√ºr den Lautsprecher wurde ein **Lochmuster** gebohrt, damit der Klang nach au√üen gelangt.  
- Innen wurden **Arduino, Breadboard und Verkabelung** sauber fixiert.  
- Mit Klebeband wurde das Setup stabilisiert, um erste Tests im ‚ÄûGeh√§use-Modus‚Äú durchzuf√ºhren.  

üëâ Zweck dieses Schritts:
- Erste **Ergonomie-Tests**: Passt das Display an der Stelle? Wie ist die Sichtbarkeit?  
- **Akustik-Test**: Wie klingt der Lautsprecher im Geh√§use?  
- **Platzcheck**: Reicht der Raum f√ºr alle Module (SD-Karte, DRV2605L, NeoPixel)?  

> Mit diesem Papp-Geh√§use entstand die erste **greifbare Version des Endprodukts**.  
> Es diente als Vorlage f√ºr sp√§tere stabilere Versionen (z. B. 3D-Druck).



---

## 2. DEMO-MEDIEN

Die folgenden Bilder und Medien zeigen das **Endprodukt** von *F√ºhle die Musik* sowie Detailansichten und ein Demo-Video.  
Sie dienen dazu, dass Nachbauer:innen sofort verstehen, wie das Projekt aussieht und funktioniert.

---

### 2.1 Hero-Foto ‚Äì fertiger Aufbau

![Fertiger Aufbau ‚Äì Frontansicht](./01_fertigesProdukt.jpeg)
![Fertiger Aufbau ‚Äì Draufsicht](./02_fertigesProdukt.jpeg)

üëâ Hier ist das **fertige Endprodukt** zu sehen:
- Das **Pappgeh√§use** enth√§lt alle Komponenten.  
- Oben befindet sich eine **rote Handauflage** aus Kunststoff, unter der sich LDR und Sensoren befinden.  
- An den Seiten sind **Bedientaster** eingelassen.  
- Ein **LED-Streifen (NeoPixel)** uml√§uft das Geh√§use und sorgt f√ºr Lichteffekte.  
- Vorne ist das **LCD 16√ó2 Display** sichtbar, das den aktuellen Song anzeigt.  

Damit wird das Motto des Projekts ‚ÄûMusik h√∂ren, sehen und f√ºhlen‚Äú sichtbar umgesetzt.

#### 2.1.1 Geh√§use-Entwicklung
Das Geh√§use sollte urspr√ºnglich **3D-gedruckt** werden.  
Wir haben ein Modell entworfen, aber es konnte **nicht in einem St√ºck gedruckt werden**, da uns kein **gr√∂√üerer 3D-Drucker** zur Verf√ºgung stand.  

Stattdessen nutzten wir ein **Pappgeh√§use** als Ersatz, um:
- die **Platzierung von Komponenten** (LCD, Lautsprecher, Taster, LDR) zu testen,  
- die **Kabeldurchf√ºhrungen** zu simulieren,  
- und die **Handauflage** auf der Oberseite auszuprobieren.  

üëâ Zur besseren Veranschaulichung wird hier ein **GIF der Geh√§useidee** erg√§nzt:

![Geh√§use-Animation](./modell-fuehle-die-musik.gif)

---

### 2.2 Schaltplan (Breadboard-Aufbau)

üëâ Eigentlich sollte hier ein **Schaltplan in Fritzing** erg√§nzt werden.  
Da dieser noch in Arbeit ist, zeigen wir zun√§chst den **realen Breadboard-Aufbau** mit allen verbundenen Modulen.  
Damit ist sofort sichtbar, wie die Module verdrahtet wurden.

![Breadboard-Aufbau mit allen Modulen](./BestandteileVonInnen.jpg)

**Erkennbar sind:**
- Oben: **Arduino UNO R4 WiFi**
- Links: **LCD 16√ó2 (I¬≤C)** mit blauer Anzeige
- Unten: **Lautsprecher** am DFPlayer Mini
- Rechts: **microSD-Modul**
- Oben & unten: **NeoPixel-Streifen**
- Mehrere **Taster** f√ºr Bedienung
- **LDR-Sensor** auf dem Breadboard


---

### 2.3 Demo-Video (15‚Äì60 s)

üé• Das Demo-Video zeigt den Ablauf:  
1. Startzustand ‚Üí System wartet.  
2. **Hand √ºber LDR** ‚Üí Musik startet.  
3. **Licht (NeoPixel) und Vibration (DRV2605L)** laufen synchron zur Musik.  
4. **LCD** zeigt den aktuellen Titel.  
5. **Songwechsel** per Tasten (hoch/runter).  


---

## 3. MATERIALS (BOM)

| Pos | Bauteil                              | Anzahl | Zweck                                    | Hinweise |
|----:|--------------------------------------|-------:|------------------------------------------|----------|
| 1   | **Arduino UNO R4 WiFi**              | 1      | Hauptcontroller, steuert alle Module     | 5 V Logik, USB-C |
| 2   | **NeoPixel LED-Streifen (WS2812)**   | 1      | Lichteffekte synchron zur Musik          | z. B. 30 LEDs; DIN ‚Üí D6 |
| 3   | **Adafruit DRV2605L Haptic Driver**  | 1      | Vibrationsausgabe                        | I¬≤C-Adresse 0x5A |
| 4   | **LDR (Lichtsensor) + 10 kŒ© Widerstand** | 1   | Erkennung ‚ÄûHand drauf = Startsignal‚Äú    | Spannungsteiler an A0 |
| 5   | **microSD-SPI-Modul + microSD (FAT32)** | 1   | Speicherung der Mapping-Dateien          | CS ‚Üí D4; MOSI/MISO/SCK √ºber ICSP |
| 6   | (Optional) **LCD 16√ó2 I¬≤C Display**  | 1      | Anzeige ‚ÄûNow Playing‚Äú + Songtitel        | Adresse 0x27 oder 0x3F |
| 7   | (Optional) **DFPlayer Mini + Lautsprecher** | 1 | MP3-Wiedergabe (Musik vom DFPlayer)      | UART √ºber Serial1 (D0/D1), eigene SD |
| 8   | **Breadboard**                       | 1      | Steckaufbau ohne L√∂ten                   | ‚Äî |
| 9   | **Jumper-Kabel (male-male, male-female)** | viele | Verbindungen zwischen Modulen            | ‚Äî |
| 10  | **USB-C Kabel**                      | 1      | Stromversorgung + Programmierung         | Direkt an PC oder an Batterie |
| 11  | **5 V Netzteil (‚â•2 A, empfohlen)**   | 1      | Externe Stromversorgung f√ºr viele LEDs   | GND mit Arduino verbinden |

> üîë **Hinweis:** Bei mehr als ~30 LEDs kann der Strombedarf sehr hoch werden (bis 60 mA pro LED bei Wei√ülicht). In diesem Fall ist eine externe 5 V-Versorgung n√∂tig.


---

## 4. EQUIPMENT

In diesem Kapitel wird alles aufgef√ºhrt, was zus√§tzlich zu den eigentlichen Bauteilen ben√∂tigt wird.  
Das hilft Einsteiger*innen, sich rechtzeitig alles bereitzulegen.

### 4.1 Equipment (Software & Ger√§te)
- **PC oder Laptop** (Windows, macOS oder Linux)
- **Arduino IDE ‚â• Version 2.x** (kostenlos: https://www.arduino.cc/en/software)
- (optional) **3D-Drucker** ‚Üí f√ºr ein eigenes Geh√§use
- (optional) **L√∂tstation** ‚Üí falls Kabel/Stecker fest verl√∂tet werden sollen
- (optional) **Fritzing** ‚Üí zur Erstellung von Schaltpl√§nen

### 4.2 Tools (Werkzeuge)
- **Breadboard** ‚Üí f√ºr den steckbaren Prototyp
- **Multimeter** ‚Üí zum Messen von Spannung und Strom (Fehlersuche)
- **Schraubendreher** ‚Üí f√ºr Anschlussklemmen
- **Abisolierzange** ‚Üí zum Vorbereiten von Kabeln
- **Pinzette** ‚Üí hilfreich bei kleinen Bauteilen
- (optional) **Hei√üklebepistole** ‚Üí Fixierung von Kabeln/Modulen im Prototyp

### 4.3 Materials (Hilfsmittel & Verbrauchsmaterial)
- **Jumper-Kabel** (male-male, male-female)
- **USB-C Kabel** (f√ºr den Arduino UNO R4 WiFi)
- **Breadboard** (falls nicht schon in BOM ber√ºcksichtigt)
- **Klebeband oder Kabelbinder** ‚Üí f√ºr sauberes Kabelmanagement
- (optional) **Geh√§usematerial** (Acrylplatten, PLA-Filament f√ºr 3D-Drucker)


---

## 5. FABRICATION FILES

Alle Dateien f√ºr das Projekt liegen in **einem einzigen Ordner** namens `MusikVibe`.  
Das macht es f√ºr Einsteiger besonders einfach: Es gibt nur einen Ordner, den man in der Arduino IDE √∂ffnen muss.

### 5.1 Quellcode (C++/Arduino)
Im Ordner `MusikVibe/` befinden sich folgende Dateien:

MusikVibe/
‚îú‚îÄ MusikVibe.ino # Hauptsketch (Einstiegspunkt)
‚îú‚îÄ display_menu.cpp # LCD-Men√º, Songauswahl, Taster-Logik
‚îú‚îÄ display_menu.h
‚îú‚îÄ effects_control.cpp # Synchronisation von Licht & Vibration
‚îú‚îÄ effects_control.h
‚îú‚îÄ ldr_sensor.cpp # LDR-Trigger (Hand √ºber Sensor = Start)
‚îú‚îÄ ldr_sensor.h
‚îú‚îÄ light_mapping.cpp # Lichteffekte aus CSV-Dateien
‚îú‚îÄ light_mapping.h
‚îú‚îÄ sound_to_vibe.cpp # Vibrationseffekte aus CSV-Dateien
‚îú‚îÄ sound_to_vibe.h





üëâ **Hinweis f√ºr Anf√§nger:**  
Die `.ino`-Datei (`MusikVibe.ino`) ist die Hauptdatei. Alle anderen Dateien sind **Module**, die automatisch mitkompiliert werden, wenn sie im gleichen Ordner liegen.  
Man muss also nur den Ordner `MusikVibe` √∂ffnen und kann alles direkt hochladen.

## 5. FABRICATION FILES

Alle Dateien f√ºr das Projekt liegen in **einem einzigen Ordner** namens `MusikVibe`.  
Das macht es f√ºr Einsteiger besonders einfach: Es gibt nur einen Ordner, den man in der Arduino IDE √∂ffnen muss.

### 5.1 Quellcode (C++/Arduino)
Im Ordner `MusikVibe/` befinden sich folgende Dateien:

MusikVibe/
‚îú‚îÄ MusikVibe.ino # Hauptsketch (Einstiegspunkt)
‚îú‚îÄ display_menu.cpp # LCD-Men√º, Songauswahl, Taster-Logik
‚îú‚îÄ display_menu.h
‚îú‚îÄ effects_control.cpp # Synchronisation von Licht & Vibration
‚îú‚îÄ effects_control.h
‚îú‚îÄ ldr_sensor.cpp # LDR-Trigger (Hand √ºber Sensor = Start)
‚îú‚îÄ ldr_sensor.h
‚îú‚îÄ light_mapping.cpp # Lichteffekte aus CSV-Dateien
‚îú‚îÄ light_mapping.h
‚îú‚îÄ sound_to_vibe.cpp # Vibrationseffekte aus CSV-Dateien
‚îú‚îÄ sound_to_vibe.h



üëâ **Hinweis f√ºr Anf√§nger:**  
Die `.ino`-Datei (`MusikVibe.ino`) ist die Hauptdatei. Alle anderen Dateien sind **Module**, die automatisch mitkompiliert werden, wenn sie im gleichen Ordner liegen.  
Man muss also nur den Ordner `MusikVibe` √∂ffnen und kann alles direkt hochladen.

---

### 5.2 SD-Karten-Dateien

Auf der **microSD-Karte** m√ºssen folgende Dateien liegen (Root-Verzeichnis):

- **`songs.txt`** ‚Üí Liste der Songs, Format:  
001,Billie Jean
002,Ode an die Freude
003,Harry Potter Intro


- **`NNN_light.csv`** ‚Üí Lichteffekte (Format: `time_ms,r,g,b`)  
- **`NNN_vibe.csv`** ‚Üí Vibrationsmuster (Format: `time_ms,pattern`)  
- **`NNN.mp3`** (optional, nur wenn DFPlayer Mini genutzt wird)  

üëâ Alle diese Dateien werden **automatisch erzeugt** durch die mitgelieferten Python-Skripte:  
- [`analyze_bass_to_csv.py`](./analyze_bass_to_csv.py) ‚Üí erzeugt Vibrationsmapping (`NNN_vibe.csv`) aus einer WAV-Datei:contentReference[oaicite:0]{index=0}  
- [`analyze_light_to_csv.py`](./analyze_light_to_csv.py) ‚Üí erzeugt Lichtmapping (`NNN_light.csv`) aus einer WAV-Datei:contentReference[oaicite:1]{index=1}  
- [`generate_mappings.py`](./generate_mappings.py) ‚Üí ruft beide Skripte auf und aktualisiert automatisch die `songs.txt`:contentReference[oaicite:2]{index=2}

üëâ **Beispielaufruf** (f√ºr einen Song mit ID 001):  
```bash

python generate_mappings.py 001 song.wav "Billie Jean"
Dies erzeugt:

001_light.csv

001_vibe.csv

tr√§gt 001,Billie Jean in songs.txt ein

```

### 5.2.1 Wie entstehen `songs.txt`, `NNN_light.csv` und `NNN_vibe.csv`?

Die Dateien auf der SD-Karte werden **automatisch** aus einer **Audio-Datei (WAV)** erzeugt.  
Daf√ºr gibt es drei Python-Skripte, die eine kleine ‚ÄûPipeline‚Äú bilden:

- [`analyze_bass_to_csv.py`](./analyze_bass_to_csv.py) ‚Üí erzeugt Vibrations-Mapping (`NNN_vibe.csv`) aus einer WAV-Datei:contentReference[oaicite:0]{index=0}  
- [`analyze_light_to_csv.py`](./analyze_light_to_csv.py) ‚Üí erzeugt Licht-Mapping (`NNN_light.csv`) aus einer WAV-Datei:contentReference[oaicite:1]{index=1}  
- [`generate_mappings.py`](./generate_mappings.py) ‚Üí ruft beide Skripte auf und aktualisiert automatisch die `songs.txt`:contentReference[oaicite:2]{index=2}

üëâ **Beispielaufruf** (f√ºr einen Song mit ID 001):  
```bash
python generate_mappings.py 001 song.wav "Billie Jean" 
```
Dies erzeugt:

001LT.csv (Lichtmapping)

001V.csv (Vibrationsmapping)

tr√§gt 001,Billie Jean in songs.txt ein

A) Vibrations-Mapping (NNNV.csv)
Was passiert: Das Skript filtert die Bassfrequenzen (< 150 Hz), erkennt Peaks √ºber einem Schwellenwert und schreibt die Zeitpunkte ins CSV.

Format:

timestamp,vibration
0,100
320,100
620,100
timestamp = Zeitpunkt in Millisekunden

vibration = Intensit√§t (Standard: 100)

Parameter (kannst du anpassen):

--bass_freq_limit ‚Üí bis zu welcher Frequenz noch ‚ÄûBass‚Äú z√§hlt (Standard 150 Hz)

--threshold_percentile ‚Üí Schwelle, ab wann ein Peak als Ereignis gilt (Standard 90 %)

--min_distance_ms ‚Üí Mindestabstand zwischen zwei Vibes (Standard 200 ms)

--sampling_interval ‚Üí Abstand zwischen ausgegebenen Werten (Standard 250 ms)

üëâ So kannst du das Mapping steuern:

Mehr Vibes ‚Üí threshold_percentile kleiner w√§hlen (z. B. 85).

Weniger Vibes ‚Üí threshold_percentile h√∂her w√§hlen (z. B. 95).

Nur tiefer Bass ‚Üí bass_freq_limit senken (z. B. 120 Hz).

B) Licht-Mapping (NNNLT.csv)
Was passiert: Das Skript sucht in jedem Analysefenster die dominante Frequenz und mappt diese √ºber HSV‚ÜíRGB auf eine Farbe.
Die Lautst√§rke bestimmt die Helligkeit.

Format:

timestamp,red,green,blue
0,255,0,0
250,0,240,0
500,0,0,255
timestamp = Zeitpunkt in Millisekunden

red/green/blue = RGB-Werte (0‚Äì255)

Parameter (kannst du anpassen):

--hop_ms ‚Üí Analyseintervall (Standard 100 ms)

--sampling_interval ‚Üí Zeitabstand zwischen Ausgaben (Standard 250 ms)

üëâ So kannst du das Mapping steuern:

Schnellere Farbwechsel ‚Üí sampling_interval kleiner (z. B. 150 ms).

Ruhigere √úberg√§nge ‚Üí sampling_interval gr√∂√üer (z. B. 400 ms).

C) Orchestrierung mit generate_mappings.py
Dieses Skript macht den Komfort aus:

ruft automatisch Bass-Analyse und Licht-Analyse auf,

legt die CSV-Dateien an (NNNV.csv, NNNLT.csv),

erg√§nzt songs.txt mit ID,Name.

üëâ Damit reicht ein Befehl pro Song und alles ist vorbereitet.

D) Was wird gemappt ‚Äì und wohin?
Zeit (ms) = gemeinsame Achse f√ºr alles

Audio (MP3) = optional, abgespielt √ºber DFPlayer Mini (NNN.mp3)

Licht (CSV) = Farben f√ºr NeoPixel (NNNLT.csv)

Vibration (CSV) = Events f√ºr DRV2605L (NNNV.csv)

songs.txt = Zuordnung ID ‚Üî Anzeigename (f√ºr LCD-Men√º)

üëâ Durch resetAllEffects() im Arduino-Code starten alle Streams synchron.

E) Typische Anpassungen
IDs immer dreistellig (001, 002, ‚Ä¶) ‚Üí f√ºr MP3 + CSV + songs.txt

Zu viele Vibes? ‚Üí --threshold_percentile erh√∂hen (95)

Zu wenige Vibes? ‚Üí --threshold_percentile senken (85)

LEDs zu tr√§ge? ‚Üí --sampling_interval kleiner (150 ms)

LEDs zu hektisch? ‚Üí --sampling_interval gr√∂√üer (400 ms)

F) Mini-Checkliste
 songs.txt enth√§lt ID + Titel

 NNNLT.csv und NNNV.csv auf SD-Karte (Root)

 (Optional) NNN.mp3 auf DFPlayer-SD

 Dateinamen ohne Leerzeichen, UTF-8

 LCD zeigt richtigen Titel, LEDs & Vibes laufen synchron

5.3 Struktur√ºbersicht
Die empfohlene Projektstruktur sieht so aus:


MusikVibe/                 # Projektordner (in Arduino IDE √∂ffnen)
‚îú‚îÄ MusikVibe.ino
‚îú‚îÄ display_menu.cpp/.h
‚îú‚îÄ effects_control.cpp/.h
‚îú‚îÄ ldr_sensor.cpp/.h
‚îú‚îÄ light_mapping.cpp/.h
‚îú‚îÄ sound_to_vibe.cpp/.h
‚îî‚îÄ (weitere Dateien folgen automatisch durch die IDE)

SD-Karte (Root)
‚îú‚îÄ songs.txt
‚îú‚îÄ 001_light.csv
‚îú‚îÄ 001_vibe.csv
‚îú‚îÄ 001.mp3 (optional)
‚îú‚îÄ 002_light.csv
‚îú‚îÄ 002_vibe.csv
‚îî‚îÄ 002.mp3 (optional)
üëâ Wichtig:

Der Ordner MusikVibe darf nicht umbenannt werden, sonst erkennt die Arduino IDE den Sketch nicht.

Die SD-Karte muss FAT32 formatiert sein.

Die CSV-Dateien und songs.txt entstehen am einfachsten mit den Python-Skripten.

---

## 6. STEP-BY-STEP INSTRUCTIONS

### Step 1: Sicherheit & √úberblick

Bevor du mit dem Aufbau beginnst, lies bitte diese Hinweise sorgf√§ltig durch.  
Sie helfen dir, Fehler und Sch√§den am Material zu vermeiden.

#### 1.1 Sicherheit
- ‚ö° **Spannung beachten:** Das gesamte Projekt arbeitet mit **5 V**.  
  ‚Üí Schlie√üe **niemals 12 V oder mehr** an, das zerst√∂rt Arduino und Module.
- üîå **Strom erst einschalten, wenn alles verkabelt ist.**  
  ‚Üí Erst nach doppelter Kontrolle verbinden.
- üîä **Lautst√§rke:** Achte bei Lautsprechern auf moderate Lautst√§rke, um Geh√∂r und Boxen zu sch√ºtzen.
- üî• **Strom f√ºr LEDs:** Ein LED-Streifen kann viel Strom ziehen (bis zu 60 mA pro LED bei Wei√ülicht).  
  ‚Üí Bei mehr als 30 LEDs ein **externes 5 V-Netzteil** nutzen und **GND mit Arduino verbinden**.
- üñêÔ∏è **Kurzschl√ºsse vermeiden:** Achte darauf, dass keine Kabel lose herumliegen oder sich ber√ºhren.
- üëÄ **Sichtpr√ºfung:** Kabel ordentlich verlegen, keine offenen Enden.

#### 1.2 √úberblick √ºber den Ablauf
Das Projekt wird in mehreren Schritten aufgebaut:

1. **Hardware verbinden**  
   - Arduino + LDR + NeoPixel + DRV2605L  
   - optional: LCD & DFPlayer  
   - gemeinsames GND sicherstellen
2. **SD-Karte vorbereiten**  
   - `songs.txt` + CSV-Dateien mit Python-Skripten erzeugen  
   - optional MP3-Dateien f√ºr DFPlayer
3. **Software vorbereiten**  
   - Arduino IDE installieren  
   - Bibliotheken installieren  
   - Projektordner `MusikVibe` √∂ffnen
4. **Code hochladen**  
   - `MusikVibe.ino` in IDE √∂ffnen  
   - Arduino UNO R4 WiFi ausw√§hlen  
   - Code kompilieren & flashen
5. **Test & Bedienung**  
   - Hand √ºber LDR ‚Üí Start  
   - Men√º-Tasten (hoch/runter) ‚Üí Songwechsel  
   - LCD zeigt Titel (falls vorhanden)  
   - LEDs & Vibration folgen Mapping-Dateien

üëâ Damit wei√üt du, wie der gesamte Ablauf aussieht.  
Im n√§chsten Schritt (**Step 2: Hardware-Aufbau**) gehen wir **Kabel f√ºr Kabel** durch.


---

## 7. SOURCE FILE ORGANIZATION

Das Projekt besteht aus **einem Ordner `MusikVibe/`**, in dem sich alle Quellcodedateien befinden.  
Die Aufteilung in mehrere `.cpp/.h`-Module macht den Code √ºbersichtlicher und erlaubt es, Funktionen getrennt zu entwickeln.

---

### 7.1 Gesamt√ºbersicht
MusikVibe/
‚îú‚îÄ MusikVibe.ino
‚îú‚îÄ display_menu.cpp / display_menu.h
‚îú‚îÄ effects_control.cpp / effects_control.h
‚îú‚îÄ ldr_sensor.cpp / ldr_sensor.h
‚îú‚îÄ light_mapping.cpp / light_mapping.h
‚îú‚îÄ sound_to_vibe.cpp / sound_to_vibe.h



---

### 7.2 Dateien im Detail

#### [`MusikVibe.ino`](./MusikVibe.ino)
- **Hauptsketch** (Einstiegspunkt der Arduino IDE).
- Initialisiert alle Module (`setupLights()`, `setupVibration()`, `setupLDR()`, LCD, DFPlayer).
- Enth√§lt die Haupt-`loop()`, die zyklisch `updateLights()`, `updateVibration()` und `handleMenuButtons()` aufruft.
- üëâ **Warum?** ‚Üí Zentraler ‚ÄûDirigent‚Äú: sorgt daf√ºr, dass alles im Takt l√§uft.

---

#### [`display_menu.cpp`](./display_menu.cpp) / [`display_menu.h`](./display_menu.h)
- Steuert das **LCD-Men√º** (LiquidCrystal_I2C).
- Funktionen:
  - `setupMenuDisplay()` ‚Üí Display initialisieren.
  - `loadSongList()` ‚Üí liest `songs.txt` und speichert IDs + Namen.
  - `updateDisplay()` ‚Üí zeigt aktuellen Titel (‚ÄûNow playing ‚Ä¶‚Äú).
  - `scrollTextRight()` ‚Üí f√ºr l√§ngere Songnamen.
  - `playSelectedSong()` ‚Üí stoppt alten Song, startet neuen via DFPlayer, l√§dt dazugeh√∂rige CSVs (`NNNLT.csv`, `NNNV.csv`).
  - `handleMenuButtons()` ‚Üí wertet Taster (hoch/runter/OK) aus und ruft `playSelectedSong()` auf.
- üëâ **Warum?** ‚Üí Das Men√º erlaubt **Songauswahl** ohne PC; Nutzer k√∂nnen zwischen Titeln wechseln.

---

#### [`effects_control.cpp`](./effects_control.cpp) / [`effects_control.h`](./effects_control.h)
- Synchronisiert **Licht** und **Vibration**.
- Funktionen:
  - `resetAllEffects()` ‚Üí setzt die Zeitbasen (Millis) f√ºr Licht & Vibration zur√ºck, Indizes auf 0.
  - Ruft `resetLights()` und `resetVibration()` auf.
- üëâ **Warum?** ‚Üí Sicherstellen, dass LEDs & Vibes **gleichzeitig** starten, sobald ein neuer Song gew√§hlt wird.

---

#### [`ldr_sensor.cpp`](./ldr_sensor.cpp) / [`ldr_sensor.h`](./ldr_sensor.h)
- Bindet den **LDR (Lichtsensor an A0)** ein.
- Funktionen:
  - `setupLDR()` ‚Üí Pin setzen, Kalibrierung starten.
  - `kalibriereLDR()` ‚Üí misst Referenzhelligkeit (Umgebungslicht).
  - `isDark()` ‚Üí pr√ºft, ob es dunkler als `referenzHelligkeit * faktor` ist ‚Üí l√∂st Start aus.
- üëâ **Warum?** ‚Üí Der LDR ist der **Trigger**, der das System ‚Äûmit der Hand abdecken = Musik + Effekte starten‚Äú ausl√∂st.

---

#### [`light_mapping.cpp`](./light_mapping.cpp) / [`light_mapping.h`](./light_mapping.h)
- Steuert den **NeoPixel LED-Streifen** (Adafruit_NeoPixel).
- Liest eine CSV mit Licht-Events (`NNNLT.csv`), z. B.:  
time_ms,r,g,b
0,255,0,0
500,0,255,0
1000,0,0,255


- Funktionen:
- `loadLightMapping()` ‚Üí CSV parsen, Events ins Array laden.
- `setupLights()` ‚Üí LEDs initialisieren.
- `updateLights()` ‚Üí setzt zur richtigen Zeit die Farben.
- `resetLights()` ‚Üí LEDs l√∂schen, Index zur√ºcksetzen.
- üëâ **Warum?** ‚Üí Um Lichteffekte **zeitlich genau** zur Musik anzuzeigen.

---

#### [`sound_to_vibe.cpp`](./sound_to_vibe.cpp) / [`sound_to_vibe.h`](./sound_to_vibe.h)
- Steuert den **DRV2605L Vibrationsmotor-Treiber** (Adafruit_DRV2605).
- Liest eine CSV mit Vibrations-Events (`NNNV.csv`), z. B.:  
time_ms,pattern
0,1
320,47
600,14


- Funktionen:
- `loadVibrationMapping()` ‚Üí CSV einlesen.
- `setupVibration()` ‚Üí DRV2605 initialisieren, Library w√§hlen, Trigger-Modus setzen.
- `updateVibration()` ‚Üí pr√ºft Zeitachse, startet das n√§chste Vibrationsmuster.
- `resetVibration()` ‚Üí Index zur√ºcksetzen.
- üëâ **Warum?** ‚Üí Damit Musik nicht nur sichtbar, sondern auch **f√ºhlbar** wird.

---

### 7.3 Zusammenfassung
- **Trennung in Module** ‚Üí klare Zust√§ndigkeiten: Display, Effekte, Sensor, Mapping.  
- **Synchronisation** √ºber `effects_control` ‚Üí alle starten gleichzeitig.  
- **Erweiterbar** ‚Üí neue Sensoren/Ausgaben k√∂nnen in eigene Module ausgelagert werden.  

üëâ Durch diese Organisation erf√ºllt das Projekt die Rubrik-Anforderung *Source File Organization (1 Punkt)*:contentReference[oaicite:0]{index=0}.


---

## 8. VISUALIZATIONS & VIDEOS
- Fotos, Schaltplan, Video einbinden
- Hinweise zur Qualit√§t (gut beleuchtet, klare Labels)

---

## 9. TROUBLESHOOTING
- Typische Probleme + L√∂sungen:
  - LCD schwarz ‚Üí falsche I¬≤C-Adresse
  - Keine Musik ‚Üí RX/TX/5 V pr√ºfen, MP3-Format
  - SD-Karte nicht erkannt ‚Üí FAT32, CS-Pin pr√ºfen
  - LEDs dunkel ‚Üí GND verbinden, externe 5 V bei vielen LEDs
  - Keine Vibration ‚Üí I¬≤C pr√ºfen, Motor korrekt angeschlossen

---

## 10. EXTENSIONS & OUTLOOK
- OK-Taste im Men√º aktivieren
- Lautst√§rkesteuerung
- Pause/Resume
- Beat-Erkennung
- Geh√§use drucken

---

## 11. LICENCE AND CREDITS
Attribution ‚Äî ShareAlike CC BY-SA  
Projekt entwickelt im Kurs **Prototyping Interactive Objects (Sommer 2025, Hochschule RheinMain, Prof. Dr. Marion Koelle)**.
